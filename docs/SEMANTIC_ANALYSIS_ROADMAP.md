# Baa Language Semantic Analysis Implementation Roadmap (New Design)

**Status: This document outlines the implementation plan for the new Semantic Analysis phase. All items are planned unless otherwise noted. This phase will operate on the AST generated by the new Parser and will align with the design in `docs/SEMANTIC_ANALYSIS.md`.**

## Phase 1: Foundation - Symbol Tables and Basic Name Resolution

- **Symbol Table Core:**
  - [ ] Design and implement basic symbol table structure (e.g., per scope).
  - [ ] Implement functions for adding symbols (variables, functions) to a scope.
  - [ ] Implement functions for looking up symbols in the current and enclosing scopes.
- **Scope Management:**
  - [ ] Implement mechanisms to create/enter new scopes (global, function, block).
  - [ ] Implement mechanisms to exit/destroy scopes.
- **Basic Name Resolution:**
  - [ ] Traverse AST for variable declarations and add them to the symbol table.
  - [ ] Traverse AST for variable usage (`BAA_EXPR_VARIABLE`) and resolve them to their declarations in the symbol table.
  - [ ] Report errors for undeclared identifiers.
- **AST Annotation (Initial):**
  - [ ] Annotate `BAA_EXPR_VARIABLE` nodes with a pointer to their symbol table entry.

## Phase 2: Basic Type Checking

- **Literal Type Checking:**
  - [ ] Assign types to literal nodes in the AST (e.g., `123` is `عدد_صحيح`, `" نص "` is `حرف[]` or a string type).
- **Variable Declaration Type Checking:**
  - [ ] If an initializer is present, check its type compatibility with the declared variable type.
- **Expression Type Checking (Simple Cases):**
  - [ ] Determine and annotate the type of simple unary and binary expressions involving literals and resolved variables.
  - [ ] Use `baa_validate_unary_op` and `baa_validate_binary_op` from `src/operators/` for basic validation.
- **Assignment Type Checking:**
  - [ ] Check type compatibility for simple assignment (`=`).

## Phase 3: Control Flow and Function Semantics

- **Function Declaration Semantics:**
  - [ ] Add function symbols to the symbol table.
  - [ ] Process parameter types and names, adding them to the function's scope.
  - [ ] Store return type information.
- **Function Call Semantics:**
  - [ ] Resolve function names.
  - [ ] Check arity (number of arguments).
  - [ ] Check argument types against parameter types (initial support).
  - [ ] Determine and annotate the type of the function call expression (based on function return type).
- **Return Statement Type Checking:**
  - [ ] Check the type of the returned expression against the current function's declared return type.
  - [ ] Ensure `إرجع` without a value is only in void functions.
  - [ ] Ensure non-void functions have `إرجع` with a value.
- **Control Flow Analysis Integration (from `src/analysis/flow_analysis.c`):**
  - [ ] Adapt `flow_analysis.c` to traverse the new AST.
  - [ ] Perform checks for `توقف` (break) and `أكمل` (continue) statement validity.
  - [ ] Perform basic "all paths return" analysis for non-void functions.
  - [ ] Detect and report unreachable code (basic).
- **Conditional Expression Type Checking:**
  - [ ] Ensure conditions in `إذا`, `طالما`, `لكل` are boolean or convertible to boolean.

## Phase 4: Advanced Type System and Semantic Rules

- **Array Type Semantics:**
  - [ ] Type checking for array indexing (`BAA_EXPR_INDEX`).
  - [ ] Type checking for array literal elements (`BAA_EXPR_ARRAY`).
- **Cast Expression Semantics (`BAA_EXPR_CAST`):**
  - [ ] Validate explicit type casts based on language rules.
- **Compound Assignment Semantics:**
  - [ ] Type checking for compound assignment operators (e.g., `+=`).
- **`ثابت` (const) Correctness:**
  - [ ] Ensure `ثابت` variables are initialized.
  - [ ] Report errors for attempts to modify `ثابت` variables.
- **`مقيد` (restrict) and `مضمن` (inline) Semantics:**
  - [ ] Implement any semantic checks related to these (if more than just hints for later stages).
- **Full Type Compatibility and Conversion Rules:**
  - [ ] Implement comprehensive rules for implicit and explicit type conversions.

## Future Considerations (Longer Term)

- [ ] Semantic analysis for `struct`, `union`, `enum` types and their usage.
- [ ] Semantic analysis for pointers.
- [ ] Advanced scope resolution (e.g., for modules, namespaces if added).
- [ ] More sophisticated type inference.
- [ ] Semantic checks for advanced language features (lambdas, pattern matching, async/await).
- [ ] Decorators/annotations.

## Error Reporting and AST Annotation

- [ ] Continuously improve error messages for clarity and precision, with correct source locations.
- [ ] Ensure all relevant AST nodes are annotated with necessary semantic information (resolved types, symbol links, etc.).

## Testing Strategy

- [ ] Develop unit tests for individual semantic checks (e.g., type compatibility function, symbol lookup).
- [ ] Create test Baa programs with various correct and incorrect semantic constructs.
- [ ] Verify that the semantic analyzer correctly annotates the AST for valid programs.
- [ ] Verify that all expected semantic errors are caught and reported correctly for invalid programs.
